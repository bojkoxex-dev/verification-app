"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var $e=require("@walletconnect/sign-client"),h=require("@walletconnect/utils"),q=require("@walletconnect/jsonrpc-utils"),G=require("@walletconnect/jsonrpc-provider"),W=require("@walletconnect/jsonrpc-http-connection"),Ae=require("events");function J(t){return t&&typeof t=="object"&&"default"in t?t:{default:t}}var Ee=J(W),je=J(Ae);function _(t){return t==null||typeof t!="object"&&typeof t!="function"}function Y(t){return Object.getOwnPropertySymbols(t).filter(e=>Object.prototype.propertyIsEnumerable.call(t,e))}function X(t){return t==null?t===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(t)}const Ce="[object RegExp]",k="[object String]",Q="[object Number]",Z="[object Boolean]",T="[object Arguments]",Ne="[object Symbol]",qe="[object Date]",_e="[object Map]",Re="[object Set]",De="[object Array]",xe="[object ArrayBuffer]",Fe="[object Object]",Ue="[object DataView]",He="[object Uint8Array]",Le="[object Uint8ClampedArray]",Be="[object Uint16Array]",Me="[object Uint32Array]",Ke="[object Int8Array]",Ve="[object Int16Array]",ze="[object Int32Array]",Ge="[object Float32Array]",We="[object Float64Array]";function R(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Je(t,e){return v(t,void 0,t,new Map,e)}function v(t,e,s,i=new Map,n=void 0){const a=n?.(t,e,s,i);if(a!=null)return a;if(_(t))return t;if(i.has(t))return i.get(t);if(Array.isArray(t)){const r=new Array(t.length);i.set(t,r);for(let c=0;c<t.length;c++)r[c]=v(t[c],c,s,i,n);return Object.hasOwn(t,"index")&&(r.index=t.index),Object.hasOwn(t,"input")&&(r.input=t.input),r}if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp){const r=new RegExp(t.source,t.flags);return r.lastIndex=t.lastIndex,r}if(t instanceof Map){const r=new Map;i.set(t,r);for(const[c,o]of t)r.set(c,v(o,c,s,i,n));return r}if(t instanceof Set){const r=new Set;i.set(t,r);for(const c of t)r.add(v(c,void 0,s,i,n));return r}if(typeof Buffer<"u"&&Buffer.isBuffer(t))return t.subarray();if(R(t)){const r=new(Object.getPrototypeOf(t)).constructor(t.length);i.set(t,r);for(let c=0;c<t.length;c++)r[c]=v(t[c],c,s,i,n);return r}if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);if(t instanceof DataView){const r=new DataView(t.buffer.slice(0),t.byteOffset,t.byteLength);return i.set(t,r),g(r,t,s,i,n),r}if(typeof File<"u"&&t instanceof File){const r=new File([t],t.name,{type:t.type});return i.set(t,r),g(r,t,s,i,n),r}if(t instanceof Blob){const r=new Blob([t],{type:t.type});return i.set(t,r),g(r,t,s,i,n),r}if(t instanceof Error){const r=new t.constructor;return i.set(t,r),r.message=t.message,r.name=t.name,r.stack=t.stack,r.cause=t.cause,g(r,t,s,i,n),r}if(typeof t=="object"&&Ye(t)){const r=Object.create(Object.getPrototypeOf(t));return i.set(t,r),g(r,t,s,i,n),r}return t}function g(t,e,s=t,i,n){const a=[...Object.keys(e),...Y(e)];for(let r=0;r<a.length;r++){const c=a[r],o=Object.getOwnPropertyDescriptor(t,c);(o==null||o.writable)&&(t[c]=v(e[c],c,s,i,n))}}function Ye(t){switch(X(t)){case T:case De:case xe:case Ue:case Z:case qe:case Ge:case We:case Ke:case Ve:case ze:case _e:case Q:case Fe:case Ce:case Re:case k:case Ne:case He:case Le:case Be:case Me:return!0;default:return!1}}function Xe(t,e){return Je(t,(s,i,n,a)=>{const r=e?.(s,i,n,a);if(r!=null)return r;if(typeof t=="object")switch(Object.prototype.toString.call(t)){case Q:case k:case Z:{const c=new t.constructor(t?.valueOf());return g(c,t),c}case T:{const c={};return g(c,t),c.length=t.length,c[Symbol.iterator]=t[Symbol.iterator],c}default:return}})}function ee(t){return Xe(t)}function te(t){return t!==null&&typeof t=="object"&&X(t)==="[object Arguments]"}function se(t){return typeof t=="object"&&t!==null}function ke(){}function Qe(t){return R(t)}function Ze(t){if(typeof t!="object"||t==null)return!1;if(Object.getPrototypeOf(t)===null)return!0;if(Object.prototype.toString.call(t)!=="[object Object]"){const s=t[Symbol.toStringTag];return s==null||!Object.getOwnPropertyDescriptor(t,Symbol.toStringTag)?.writable?!1:t.toString()===`[object ${s}]`}let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}function Te(t){if(_(t))return t;if(Array.isArray(t)||R(t)||t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);const e=Object.getPrototypeOf(t),s=e.constructor;if(t instanceof Date||t instanceof Map||t instanceof Set)return new s(t);if(t instanceof RegExp){const i=new s(t);return i.lastIndex=t.lastIndex,i}if(t instanceof DataView)return new s(t.buffer.slice(0));if(t instanceof Error){const i=new s(t.message);return i.stack=t.stack,i.name=t.name,i.cause=t.cause,i}if(typeof File<"u"&&t instanceof File)return new s([t],t.name,{type:t.type,lastModified:t.lastModified});if(typeof t=="object"){const i=Object.create(e);return Object.assign(i,t)}return t}function et(t,...e){const s=e.slice(0,-1),i=e[e.length-1];let n=t;for(let a=0;a<s.length;a++){const r=s[a];n=I(n,r,i,new Map)}return n}function I(t,e,s,i){if(_(t)&&(t=Object(t)),e==null||typeof e!="object")return t;if(i.has(e))return Te(i.get(e));if(i.set(e,t),Array.isArray(e)){e=e.slice();for(let a=0;a<e.length;a++)e[a]=e[a]??void 0}const n=[...Object.keys(e),...Y(e)];for(let a=0;a<n.length;a++){const r=n[a];let c=e[r],o=t[r];if(te(c)&&(c={...c}),te(o)&&(o={...o}),typeof Buffer<"u"&&Buffer.isBuffer(c)&&(c=ee(c)),Array.isArray(c))if(typeof o=="object"&&o!=null){const u=[],p=Reflect.ownKeys(o);for(let m=0;m<p.length;m++){const d=p[m];u[d]=o[d]}o=u}else o=[];const l=s(o,c,r,t,e,i);l!=null?t[r]=l:Array.isArray(c)||se(o)&&se(c)?t[r]=I(o,c,s,i):o==null&&Ze(c)?t[r]=I({},c,s,i):o==null&&Qe(c)?t[r]=ee(c):(o===void 0||c!==void 0)&&(t[r]=c)}return t}function tt(t,...e){return et(t,...e,ke)}const ie="error",st="wss://relay.walletconnect.org",it="wc",re="universal_provider",S=`${it}@2:${re}:`,ne="https://rpc.walletconnect.org/v1/",ae="generic",rt=`${ne}bundler`,w="call_status",nt=86400,D={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};var at=Object.defineProperty,ct=Object.defineProperties,ot=Object.getOwnPropertyDescriptors,ce=Object.getOwnPropertySymbols,pt=Object.prototype.hasOwnProperty,ht=Object.prototype.propertyIsEnumerable,oe=(t,e,s)=>e in t?at(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,$=(t,e)=>{for(var s in e||(e={}))pt.call(e,s)&&oe(t,s,e[s]);if(ce)for(var s of ce(e))ht.call(e,s)&&oe(t,s,e[s]);return t},lt=(t,e)=>ct(t,ot(e));function pe(t,e,s){var i;const n=h.parseChainId(t);return((i=e.rpcMap)==null?void 0:i[n.reference])||`${ne}?chainId=${n.namespace}:${n.reference}&projectId=${s}`}function ut(t){return t.includes(":")?t.split(":")[1]:t}function he(t){return t.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function dt(t,e){const s=Object.keys(e.namespaces).filter(n=>n.includes(t));if(!s.length)return[];const i=[];return s.forEach(n=>{const a=e.namespaces[n].accounts;i.push(...a)}),i}function le(t){return Object.fromEntries(Object.entries(t).filter(([e,s])=>{var i,n;return((i=s?.chains)==null?void 0:i.length)&&((n=s?.chains)==null?void 0:n.length)>0}))}function A(t={},e={}){const s=le(ue(t)),i=le(ue(e));return tt(s,i)}function ue(t){var e,s,i,n,a;const r={};if(!h.isValidObject(t))return r;for(const[c,o]of Object.entries(t)){const l=h.isCaipNamespace(c)?[c]:o.chains,u=o.methods||[],p=o.events||[],m=o.rpcMap||{},d=h.parseNamespaceKey(c);r[d]=lt($($({},r[d]),o),{chains:h.mergeArrays(l,(e=r[d])==null?void 0:e.chains),methods:h.mergeArrays(u,(s=r[d])==null?void 0:s.methods),events:h.mergeArrays(p,(i=r[d])==null?void 0:i.events)}),(h.isValidObject(m)||h.isValidObject(((n=r[d])==null?void 0:n.rpcMap)||{}))&&(r[d].rpcMap=$($({},m),(a=r[d])==null?void 0:a.rpcMap))}return r}function de(t){return t.includes(":")?t.split(":")[2]:t}function fe(t){const e={};for(const[s,i]of Object.entries(t)){const n=i.methods||[],a=i.events||[],r=i.accounts||[],c=h.isCaipNamespace(s)?[s]:i.chains?i.chains:he(i.accounts);e[s]={chains:c,methods:n,events:a,accounts:r}}return e}function x(t){return typeof t=="number"?t:t.includes("0x")?parseInt(t,16):(t=t.includes(":")?t.split(":")[1]:t,isNaN(Number(t))?t:Number(t))}function ft(t){try{const e=JSON.parse(t);return typeof e=="object"&&e!==null&&!Array.isArray(e)}catch{return!1}}const me={},b=t=>me[t],F=(t,e)=>{me[t]=e};var mt=Object.defineProperty,ge=Object.getOwnPropertySymbols,gt=Object.prototype.hasOwnProperty,yt=Object.prototype.propertyIsEnumerable,ye=(t,e,s)=>e in t?mt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,ve=(t,e)=>{for(var s in e||(e={}))gt.call(e,s)&&ye(t,s,e[s]);if(ge)for(var s of ge(e))yt.call(e,s)&&ye(t,s,e[s]);return t};const we="eip155",vt=["atomic","flow-control","paymasterService","sessionKeys","auxiliaryFunds"],wt=t=>t&&t.startsWith("0x")?BigInt(t).toString(10):t,U=t=>t&&t.startsWith("0x")?t:`0x${BigInt(t).toString(16)}`,be=t=>Object.keys(t).filter(e=>vt.includes(e)).reduce((e,s)=>(e[s]=bt(t[s]),e),{}),bt=t=>typeof t=="string"&&ft(t)?JSON.parse(t):t,Pt=(t,e,s)=>{const{sessionProperties:i={},scopedProperties:n={}}=t,a={};if(!h.isValidObject(n)&&!h.isValidObject(i))return;const r=be(i);for(const c of s){const o=wt(c);if(!o)continue;a[U(o)]=r;const l=n?.[`${we}:${o}`];if(l){const u=l?.[`${we}:${o}:${e}`];a[U(o)]=ve(ve({},a[U(o)]),be(u||l))}}for(const[c,o]of Object.entries(a))Object.keys(o).length===0&&delete a[c];return Object.keys(a).length>0?a:void 0};var Ot=Object.defineProperty,It=(t,e,s)=>e in t?Ot(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,St=(t,e,s)=>It(t,typeof e!="symbol"?e+"":e,s);let H;class V{constructor(e){St(this,"storage"),this.storage=e}async getItem(e){return await this.storage.getItem(e)}async setItem(e,s){return await this.storage.setItem(e,s)}async removeItem(e){return await this.storage.removeItem(e)}static getStorage(e){return H||(H=new V(e)),H}}var $t=Object.defineProperty,At=Object.defineProperties,Et=Object.getOwnPropertyDescriptors,Pe=Object.getOwnPropertySymbols,jt=Object.prototype.hasOwnProperty,Ct=Object.prototype.propertyIsEnumerable,Oe=(t,e,s)=>e in t?$t(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,Nt=(t,e)=>{for(var s in e||(e={}))jt.call(e,s)&&Oe(t,s,e[s]);if(Pe)for(var s of Pe(e))Ct.call(e,s)&&Oe(t,s,e[s]);return t},qt=(t,e)=>At(t,Et(e));async function _t(t,e){const s=h.parseChainId(t.result.capabilities.caip345.caip2),i=t.result.capabilities.caip345.transactionHashes,n=await Promise.allSettled(i.map(p=>Rt(s.reference,p,e))),a=n.filter(p=>p.status==="fulfilled").map(p=>p.value).filter(p=>p);n.filter(p=>p.status==="rejected").forEach(p=>console.warn("Failed to fetch transaction receipt:",p.reason));const r=!a.length||a.some(p=>!p),c=a.every(p=>p?.status==="0x1"),o=a.every(p=>p?.status==="0x0"),l=a.some(p=>p?.status==="0x0");let u;return r?u=100:c?u=200:o?u=500:l&&(u=600),{id:t.result.id,version:t.request.version,atomic:t.request.atomicRequired,chainId:t.request.chainId,capabilities:t.result.capabilities,receipts:a,status:u}}async function Rt(t,e,s){return await s(parseInt(t)).request(q.formatJsonRpcRequest("eth_getTransactionReceipt",[e]))}async function Dt({sendCalls:t,storage:e}){const s=await e.getItem(w);await e.setItem(w,qt(Nt({},s),{[t.result.id]:{request:t.request,result:t.result,expiry:h.calcExpiry(nt)}}))}async function xt({resultId:t,storage:e}){const s=await e.getItem(w);if(s){delete s[t],await e.setItem(w,s);for(const i in s)h.isExpired(s[i].expiry)&&delete s[i];await e.setItem(w,s)}}async function Ft({resultId:t,storage:e}){const s=await e.getItem(w),i=s?.[t];if(i&&!h.isExpired(i.expiry))return i;await xt({resultId:t,storage:e})}var Ut=Object.defineProperty,Ht=Object.defineProperties,Lt=Object.getOwnPropertyDescriptors,Ie=Object.getOwnPropertySymbols,Bt=Object.prototype.hasOwnProperty,Mt=Object.prototype.propertyIsEnumerable,L=(t,e,s)=>e in t?Ut(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,B=(t,e)=>{for(var s in e||(e={}))Bt.call(e,s)&&L(t,s,e[s]);if(Ie)for(var s of Ie(e))Mt.call(e,s)&&L(t,s,e[s]);return t},M=(t,e)=>Ht(t,Lt(e)),y=(t,e,s)=>L(t,typeof e!="symbol"?e+"":e,s);class Kt{constructor(e){y(this,"name","eip155"),y(this,"client"),y(this,"chainId"),y(this,"namespace"),y(this,"httpProviders"),y(this,"events"),y(this,"storage"),this.namespace=e.namespace,this.events=b("events"),this.client=b("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain()),this.storage=V.getStorage(this.client.core.storage)}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e);case"wallet_sendCalls":return await this.sendCalls(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(parseInt(e),s);const i=this.chainId;this.chainId=parseInt(e),this.events.emit(D.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,s){const i=s||pe(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new G.JsonRpcProvider(new W.HttpConnection(i,b("disableProviderPing")))}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(s=>{var i;const n=parseInt(ut(s));e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[s])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}getHttpProvider(e){const s=e||this.chainId;return this.httpProviders[s]||(this.httpProviders=M(B({},this.httpProviders),{[s]:this.createHttpProvider(s)}),this.httpProviders[s])}async handleSwitchChain(e){var s,i;let n=e.request.params?(s=e.request.params[0])==null?void 0:s.chainId:"0x0";n=n.startsWith("0x")?n:`0x${n}`;const a=parseInt(n,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:n}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var s,i,n,a,r;const c=(i=(s=e.request)==null?void 0:s.params)==null?void 0:i[0],o=((a=(n=e.request)==null?void 0:n.params)==null?void 0:a[1])||[];if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const l=this.client.session.get(e.topic),u=((r=l?.sessionProperties)==null?void 0:r.capabilities)||{},p=o.length>0?o.join(","):`0x${this.chainId.toString(16)}`,m=`${c}${p}`,d=u?.[m];if(d)return d;let C;try{C=Pt(l,c,o)}catch(N){console.warn("Failed to extract capabilities from session",N)}if(C)return C;const z=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:M(B({},l.sessionProperties||{}),{capabilities:M(B({},u||{}),{[m]:z})})})}catch(N){console.warn("Failed to update session with capabilities",N)}return z}async getCallStatus(e){var s,i,n;const a=this.client.session.get(e.topic),r=(s=a.sessionProperties)==null?void 0:s.bundler_name;if(r){const l=this.getBundlerUrl(e.chainId,r);try{return await this.getUserOperationReceipt(l,e)}catch(u){console.warn("Failed to fetch call status from bundler",u,l)}}const c=(i=a.sessionProperties)==null?void 0:i.bundler_url;if(c)try{return await this.getUserOperationReceipt(c,e)}catch(l){console.warn("Failed to fetch call status from custom bundler",l,c)}const o=await Ft({resultId:(n=e.request.params)==null?void 0:n[0],storage:this.storage});if(o)try{return await _t(o,this.getHttpProvider.bind(this))}catch(l){console.warn("Failed to fetch call status from stored send calls",l,o)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,s){var i;const n=new URL(e),a=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(q.formatJsonRpcRequest("eth_getUserOperationReceipt",[(i=s.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(e,s){return`${rt}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${s}`}async sendCalls(e){var s,i,n;const a=await this.client.request(e),r=(s=e.request.params)==null?void 0:s[0],c=a?.id,o=a?.capabilities||{},l=(i=o?.caip345)==null?void 0:i.caip2,u=(n=o?.caip345)==null?void 0:n.transactionHashes;return!c||!l||!(u!=null&&u.length)||await Dt({sendCalls:{request:r,result:a},storage:this.storage}),a}}var Vt=Object.defineProperty,zt=(t,e,s)=>e in t?Vt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,P=(t,e,s)=>zt(t,typeof e!="symbol"?e+"":e,s);class Gt{constructor(e){P(this,"name",ae),P(this,"client"),P(this,"httpProviders"),P(this,"events"),P(this,"namespace"),P(this,"chainId"),this.namespace=e.namespace,this.events=b("events"),this.client=b("client"),this.chainId=this.getDefaultChain(),this.name=this.getNamespaceName(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(e,s);const i=this.chainId;this.chainId=e,this.events.emit(D.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getNamespaceName(){const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return h.parseChainId(e).namespace}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}createHttpProviders(){var e,s;const i={};return(s=(e=this.namespace)==null?void 0:e.accounts)==null||s.forEach(n=>{var a,r;const c=h.parseChainId(n),o=(r=(a=this.namespace)==null?void 0:a.rpcMap)==null?void 0:r[`${c.namespace}:${c.reference}`];i[c.reference]=this.createHttpProvider(n,o)}),i}getHttpProvider(e){const s=h.parseChainId(e).reference,i=this.httpProviders[s];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return i}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProvider(e,s){const i=s||pe(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new G.JsonRpcProvider(new Ee.default(i,b("disableProviderPing")))}}var Wt=Object.defineProperty,Jt=Object.defineProperties,Yt=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Xt=Object.prototype.hasOwnProperty,kt=Object.prototype.propertyIsEnumerable,K=(t,e,s)=>e in t?Wt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,O=(t,e)=>{for(var s in e||(e={}))Xt.call(e,s)&&K(t,s,e[s]);if(Se)for(var s of Se(e))kt.call(e,s)&&K(t,s,e[s]);return t},E=(t,e)=>Jt(t,Yt(e)),f=(t,e,s)=>K(t,typeof e!="symbol"?e+"":e,s);class j{constructor(e){f(this,"client"),f(this,"namespaces"),f(this,"optionalNamespaces"),f(this,"sessionProperties"),f(this,"scopedProperties"),f(this,"events",new je.default),f(this,"rpcProviders",{}),f(this,"session"),f(this,"providerOpts"),f(this,"logger"),f(this,"uri"),f(this,"disableProviderPing",!1),f(this,"connectParams");var s,i;this.providerOpts=e,this.logger=h.createLogger({logger:(s=e.logger)!=null?s:ie,name:(i=this.providerOpts.name)!=null?i:re}),this.disableProviderPing=e?.disableProviderPing||!1}static async init(e){const s=new j(e);return await s.initialize(),s}async request(e,s,i){const[n,a]=this.validateChain(s);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(n).request({request:O({},e),chainId:`${n}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(e,s,i,n){const a=new Date().getTime();this.request(e,i,n).then(r=>s(null,q.formatJsonRpcResult(a,r))).catch(r=>s(r,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:h.getSdkError("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.connectParams=e,this.setNamespaces(e),this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,s){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:i,response:n}=await this.client.authenticate(e,s);i&&(this.uri=i,this.events.emit("display_uri",i));const a=await n();if(this.session=a.session,this.session){const r=fe(this.session.namespaces);this.namespaces=A(this.namespaces,r),await this.persist("namespaces",this.namespaces),this.onConnect()}return a}on(e,s){this.events.on(e,s)}once(e,s){this.events.once(e,s)}removeListener(e,s){this.events.removeListener(e,s)}off(e,s){this.events.off(e,s)}get isWalletConnect(){return!0}async pair(e){var s,i;const{uri:n,approval:a}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties,authentication:(s=this.connectParams)==null?void 0:s.authentication,walletPay:(i=this.connectParams)==null?void 0:i.walletPay});n&&(this.uri=n,this.events.emit("display_uri",n));const r=await a();this.session=r;const c=fe(r.namespaces);return this.namespaces=A(this.namespaces,c),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,s){try{if(!this.session)return;const[i,n]=this.validateChain(e);this.getProvider(i).setDefaultChain(n,s)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(e={}){try{this.logger.info("Cleaning up inactive pairings...");const s=this.client.pairing.getAll();if(!h.isValidArray(s))return;for(const i of s)e.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${s.length}`)}catch(s){this.logger.warn(s,"Failed to cleanup pending pairings")}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,s;if(this.client=this.providerOpts.client||await $e.SignClient.init({core:this.providerOpts.core,logger:this.providerOpts.logger||ie,relayUrl:this.providerOpts.relayUrl||st,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error(i,"Failed to get session"),new Error(`The provided session: ${(s=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:s.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(s=>h.parseNamespaceKey(s)))];F("client",this.client),F("events",this.events),F("disableProviderPing",this.disableProviderPing),e.forEach(s=>{if(!this.session)return;const i=dt(s,this.session);if(i?.length===0)return;const n=he(i),a=A(this.namespaces,this.optionalNamespaces),r=E(O({},a[s]),{accounts:i,chains:n});switch(s){case"eip155":this.rpcProviders[s]=new Kt({namespace:r});break;default:this.rpcProviders[s]=new Gt({namespace:r})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var s;const{topic:i}=e;i===((s=this.session)==null?void 0:s.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var s;const{params:i,topic:n}=e;if(n!==((s=this.session)==null?void 0:s.topic))return;const{event:a}=i;if(a.name==="accountsChanged"){const r=a.data;r&&h.isValidArray(r)&&this.events.emit("accountsChanged",r.map(de))}else if(a.name==="chainChanged"){const r=i.chainId,c=i.event.data,o=h.parseNamespaceKey(r),l=x(r)!==x(c)?`${o}:${x(c)}`:r;this.onChainChanged({currentCaipChainId:l})}else this.events.emit(a.name,a.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:s})=>{var i,n;if(e!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=s,r=(n=this.client)==null?void 0:n.session.get(e);this.session=E(O({},r),{namespaces:a}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:s})}),this.client.on("session_delete",async e=>{var s;e.topic===((s=this.session)==null?void 0:s.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",E(O({},h.getSdkError("USER_DISCONNECTED")),{data:e.topic})))}),this.on(D.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(E(O({},e),{internal:!0}))})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[ae]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var s;this.getProvider(e).updateNamespace((s=this.session)==null?void 0:s.namespaces[e])})}setNamespaces(e){const{namespaces:s={},optionalNamespaces:i={},sessionProperties:n,scopedProperties:a}=e;this.optionalNamespaces=A(s,i),this.sessionProperties=n,this.scopedProperties=a}validateChain(e){const[s,i]=e?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[s,i];if(s&&!Object.keys(this.namespaces||{}).map(r=>h.parseNamespaceKey(r)).includes(s))throw new Error(`Namespace '${s}' is not configured. Please call connect() first with namespace config.`);if(s&&i)return[s,i];const n=h.parseNamespaceKey(Object.keys(this.namespaces)[0]),a=this.rpcProviders[n].getDefaultChain();return[n,a]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged({currentCaipChainId:e,previousCaipChainId:s,internal:i=!1}){if(!this.namespaces)return;const[n,a]=this.validateChain(e);a&&(this.updateNamespaceChain(n,a),i?(this.events.emit("chainChanged",a),this.emitAccountsChangedOnChainChange({namespace:n,currentCaipChainId:e,previousCaipChainId:s})):this.getProvider(n).setDefaultChain(a),await this.persist("namespaces",this.namespaces))}emitAccountsChangedOnChainChange({namespace:e,currentCaipChainId:s,previousCaipChainId:i}){var n,a;try{if(i===s)return;const r=(a=(n=this.session)==null?void 0:n.namespaces[e])==null?void 0:a.accounts;if(!r)return;const c=r.filter(o=>o.includes(`${s}:`)).map(de);if(!h.isValidArray(c))return;this.events.emit("accountsChanged",c)}catch(r){this.logger.warn(r,"Failed to emit accountsChanged on chain change")}}updateNamespaceChain(e,s){if(!this.namespaces)return;const i=this.namespaces[e]?e:`${e}:${s}`,n={chains:[],methods:[],events:[],defaultChain:s};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=s):this.namespaces[i]=n}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.connectParams=void 0,this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,s){var i;const n=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${S}/${e}${n}`,s)}async getFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";return await this.client.core.storage.getItem(`${S}/${e}${i}`)}async deleteFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.removeItem(`${S}/${e}${i}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const s=await this.client.core.storage.getKeys();for(const i of s)i.startsWith(S)&&await this.client.core.storage.removeItem(i)}catch(s){this.logger.warn(s,"Failed to cleanup storage")}}}const Qt=j;exports.UniversalProvider=Qt,exports.default=j;
//# sourceMappingURL=index.cjs.map
